From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Noah van der Aa <ndvdaa@gmail.com>
Date: Tue, 3 Aug 2021 17:28:27 +0200
Subject: [PATCH] Hide unnecessary itemmeta from clients


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index fd5927247e23878fd8bf6ab62a2eb477d07f4cc3..19ee843fa118a3b1b2c6b5551e9c6af7e7fcca11 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -916,6 +916,13 @@ public class PaperWorldConfig {
         behaviorTickRates = loadTickRates("behavior");
     }
 
+    public boolean hideItemmetaFromClients = true;
+    public boolean hideDurabilityFromClients = false;
+    private void getHideItemmetaFromClients() {
+        hideItemmetaFromClients = getBoolean("anticheat.obfuscation.items.hide-itemmeta", hideItemmetaFromClients);
+        hideDurabilityFromClients = getBoolean("anticheat.obfuscation.items.hide-durability", hideDurabilityFromClients);
+    }
+
     private com.google.common.collect.Table<String, String, Integer> loadTickRates(String type) {
         log("  " + type + ":");
         com.google.common.collect.Table<String, String, Integer> table = com.google.common.collect.HashBasedTable.create();
diff --git a/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java b/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java
index 3eb6bf4258b1de4697f96c2011df493cf7414a0c..7b7fe3f47144aa92b335aa4cc55e7e897ac11fc8 100644
--- a/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java
+++ b/src/main/java/net/minecraft/network/syncher/EntityDataSerializers.java
@@ -127,6 +127,7 @@ public class EntityDataSerializers {
     public static final EntityDataSerializer<ItemStack> ITEM_STACK = new EntityDataSerializer<ItemStack>() {
         @Override
         public void write(FriendlyByteBuf buf, ItemStack value) {
+            value = net.minecraft.world.entity.LivingEntity.stripMeta(value, null, false); // Paper - strip items to prevent oversized data
             buf.writeItem(value);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 62daf918d4ab00963041ca869ae718f14f2e3337..a7ab33d1a6c30ffde7bf2ab8588df4437197fb9a 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3047,13 +3047,67 @@ public abstract class LivingEntity extends Entity {
 
     }
 
+    public static ItemStack stripMeta(ItemStack itemStack, @org.jetbrains.annotations.Nullable Level level, boolean copy) {
+        if ((itemStack.getCount() > 1 || itemStack.hasTag()) && !itemStack.isEmpty()) {
+            if (copy) itemStack = itemStack.copy();
+            CompoundTag nbt = itemStack.getTag();
+            if (level != null && level.paperConfig.hideDurabilityFromClients) {
+                // Only show damage values for elytra's, since they show a different texture when broken.
+                if (!itemStack.is(Items.ELYTRA) || itemStack.getDamageValue() < itemStack.getMaxDamage() - 1) {
+                    itemStack.setDamageValue(0);
+                }
+            }
+
+            if (level != null && level.paperConfig.hideItemmetaFromClients) {
+                // Some resource packs show different textures when there is more than one item. Since this shouldn't provide a big advantage,
+                // we'll tell the client if there's one or (more than) two items.
+                itemStack.setCount(itemStack.getCount() > 1 ? 2 : 1);
+                // We can't just strip out display, leather helmets still use the display.color tag.
+                if (nbt != null) {
+                    if (nbt.get("display") instanceof CompoundTag displayTag) {
+                        displayTag.remove("Lore");
+                        displayTag.remove("Name");
+                    }
+
+                    if (nbt.get("Enchantments") instanceof ListTag enchantmentsTag && !enchantmentsTag.isEmpty()) {
+                        // The client still renders items with the enchantment glow if the enchantments tag contains at least one (empty) child.
+                        ListTag enchantments = new ListTag();
+                        enchantments.add(new CompoundTag());
+                        nbt.put("Enchantments", enchantments);
+                    }
+                    nbt.remove("AttributeModifiers");
+                }
+            }
+            // Always remove items to prevent oversized data
+            // Bundles change their texture based on their fullness.
+            if (nbt != null) {
+                if (itemStack.is(Items.BUNDLE) && nbt.get("Items") instanceof ListTag oldItems && !oldItems.isEmpty()) {
+                    org.bukkit.inventory.meta.BundleMeta bundleMeta = (org.bukkit.inventory.meta.BundleMeta) itemStack.asBukkitMirror().getItemMeta();
+                    int sizeUsed = 0;
+                    for (org.bukkit.inventory.ItemStack item : bundleMeta.getItems()) {
+                        int scale = 64 / item.getMaxStackSize();
+                        sizeUsed += scale * item.getAmount();
+                    }
+                    // Now we add a single fake item that uses the same amount of slots as all other items.
+                    ListTag items = new ListTag();
+                    items.add(new ItemStack(Items.PAPER, sizeUsed).save(new CompoundTag()));
+                    nbt.put("Items", items);
+                }
+                nbt.remove("BlockEntityTag");
+                nbt.remove("EntityTag");
+            }
+        }
+        return itemStack;
+    }
+
     private void handleEquipmentChanges(Map<EquipmentSlot, ItemStack> equipmentChanges) {
         List<Pair<EquipmentSlot, ItemStack>> list = Lists.newArrayListWithCapacity(equipmentChanges.size());
 
         equipmentChanges.forEach((enumitemslot, itemstack) -> {
             ItemStack itemstack1 = itemstack.copy();
+            final ItemStack toSend = stripMeta(itemstack1, this.level, true); // Paper - hide unnecessary itemmeta from clients
 
-            list.add(Pair.of(enumitemslot, itemstack1));
+            list.add(Pair.of(enumitemslot, toSend)); // Paper - hide unnecessary itemmeta from clients
             switch (enumitemslot.getType()) {
                 case HAND:
                     this.setLastHandItem(enumitemslot, itemstack1);
